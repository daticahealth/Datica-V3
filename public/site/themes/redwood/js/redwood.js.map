{"version":3,"sources":["collage-plus.js","zoom.js","jabbascripts.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"redwood.js","sourcesContent":["/*!\n *\n * jQuery collagePlus Plugin v0.3.3\n * https://github.com/ed-lea/jquery-collagePlus\n *\n * Copyright 2012, Ed Lea twitter.com/ed_lea\n *\n * built for http://qiip.me\n *\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://www.opensource.org/licenses/mit-license.php\n * http://www.opensource.org/licenses/GPL-2.0\n *\n */\n\n\n\n\n\n;(function( $ ) {\n\n\n    $.fn.collagePlus = function( options ) {\n\n        return this.each(function() {\n\n            /*\n             *\n             * set up vars\n             *\n             */\n\n            // track row width by adding images, padding and css borders etc\n            var row         = 0,\n            // collect elements to be re-sized in current row\n                elements    = [],\n            // track the number of rows generated\n                rownum = 1,\n            // needed for creating some additional defaults that are actually obtained\n            // from the dom, which maybe doesn't make them defaults ?!\n                $this = $(this);\n\n\n            // width of the area the collage will be in\n            $.fn.collagePlus.defaults.albumWidth    = $this.width();\n            // padding between the images. Using padding left as we assume padding is even all the way round\n            $.fn.collagePlus.defaults.padding       = parseFloat( $this.css('padding-left') );\n            // object that contains the images to collage\n            $.fn.collagePlus.defaults.images        = $this.children();\n\n            var settings = $.extend({}, $.fn.collagePlus.defaults, options);\n\n            settings.images.each(\n                function(index){\n\n                    /*\n                     *\n                     * Cache selector\n                     * Even if first child is not an image the whole sizing is based on images\n                     * so where we take measurements, we take them on the images\n                     *\n                     */\n                    var $this = $(this),\n                        $img  = ($this.is(\"img\")) ? $this : $(this).find(\"img\");\n\n\n\n                    /*\n                     *\n                     * get the current image size. Get image size in this order\n                     *\n                     * 1. from <img> tag\n                     * 2. from data set from initial calculation\n                     * 3. after loading the image and checking it's actual size\n                     *\n                     */\n                    var w = (typeof $img.data(\"width\") != 'undefined') ? $img.data(\"width\") : $img.width(),\n                        h = (typeof $img.data(\"height\") != 'undefined') ? $img.data(\"height\") : $img.height();\n\n\n\n                    /*\n                     *\n                     * Get any current additional properties that may affect the width or height\n                     * like css borders for example\n                     *\n                     */\n                    var imgParams = getImgProperty($img);\n\n\n                    /*\n                     *\n                     * store the original size for resize events\n                     *\n                     */\n                    $img.data(\"width\", w);\n                    $img.data(\"height\", h);\n\n\n\n                    /*\n                     *\n                     * calculate the w/h based on target height\n                     * this is our ideal size, but later we'll resize to make it fit\n                     *\n                     */\n                    var nw = Math.ceil(w/h*settings.targetHeight),\n                        nh = Math.ceil(settings.targetHeight);\n\n                    /*\n                     *\n                     * Keep track of which images are in our row so far\n                     *\n                     */\n                    elements.push([this, nw, nh, imgParams['w'], imgParams['h']]);\n\n                    /*\n                     *\n                     * calculate the width of the element including extra properties\n                     * like css borders\n                     *\n                     */\n                    row += nw + imgParams['w'] + settings.padding;\n\n                    /*\n                     *\n                     * if the current row width is wider than the parent container\n                     * it's time to make a row out of our images\n                     *\n                     */\n                    if( row > settings.albumWidth && elements.length != 0 ){\n\n                        // call the method that calculates the final image sizes\n                        // remove one set of padding as it's not needed for the last image in the row\n                        resizeRow(elements, (row - settings.padding), settings, rownum);\n\n                        // reset our row\n                        delete row;\n                        delete elements;\n                        row         = 0;\n                        elements    = [];\n                        rownum      += 1;\n                    }\n\n\n                    /*\n                     *\n                     * if the images left are not enough to make a row\n                     * then we'll force them to make one anyway\n                     *\n                     */\n                    if ( settings.images.length-1 == index && elements.length != 0){\n                        resizeRow(elements, row, settings, rownum);\n\n                        // reset our row\n                        delete row;\n                        delete elements;\n                        row         = 0;\n                        elements    = [];\n                        rownum      += 1;\n                    }\n                }\n            );\n\n        });\n\n        function resizeRow( obj, row, settings, rownum) {\n\n            /*\n             *\n             * How much bigger is this row than the available space?\n             * At this point we have adjusted the images height to fit our target height\n             * so the image size will already be different from the original.\n             * The resizing we're doing here is to adjust it to the album width.\n             *\n             * We also need to change the album width (basically available space) by\n             * the amount of padding and css borders for the images otherwise\n             * this will skew the result.\n             *\n             * This is because padding and borders remain at a fixed size and we only\n             * need to scale the images.\n             *\n             */\n            var imageExtras         = (settings.padding * (obj.length - 1)) + (obj.length * obj[0][3]),\n                albumWidthAdjusted  = settings.albumWidth - imageExtras,\n                overPercent         = albumWidthAdjusted / (row - imageExtras),\n                // start tracking our width with know values that will make up the total width\n                // like borders and padding\n                trackWidth          = imageExtras,\n                // guess whether this is the last row in a set by checking if the width is less\n                // than the parent width.\n                lastRow             = (row < settings.albumWidth  ? true : false);\n\n\n\n\n\n            /*\n             * Resize the images by the above % so that they'll fit in the album space\n             */\n            for (var i = 0; i < obj.length; i++) {\n\n\n\n                var $obj        = $(obj[i][0]),\n                    fw          = Math.floor(obj[i][1] * overPercent),\n                    fh          = Math.floor(obj[i][2] * overPercent),\n                // if the element is the last in the row,\n                // don't apply right hand padding (this is our flag for later)\n                    isNotLast   = !!(( i < obj.length - 1 ));\n\n                /*\n                 * Checking if the user wants to not stretch the images of the last row to fit the\n                 * parent element size\n                 */\n                if(settings.allowPartialLastRow === true && lastRow === true){\n                   fw = obj[i][1];\n                   fh = obj[i][2];\n                }\n\n\n                /*\n                 *\n                 * Because we use % to calculate the widths, it's possible that they are\n                 * a few pixels out in which case we need to track this and adjust the\n                 * last image accordingly\n                 *\n                 */\n                trackWidth += fw;\n\n\n                /*\n                 *\n                 * here we check if the combined images are exactly the width\n                 * of the parent. If not then we add a few pixels on to make\n                 * up the difference.\n                 *\n                 * This will alter the aspect ratio of the image slightly, but\n                 * by a noticable amount.\n                 *\n                 * If the user doesn't want full width last row, we check for that here\n                 *\n                 */\n                if(!isNotLast && trackWidth < settings.albumWidth){\n                    if(settings.allowPartialLastRow === true && lastRow === true){\n                        fw = fw;\n                    }else{\n                        fw = fw + (settings.albumWidth - trackWidth);\n                    }\n                }\n\n                fw--;\n\n                /*\n                 *\n                 * We'll be doing a few things to the image so here we cache the image selector\n                 *\n                 *\n                 */\n                var $img = ( $obj.is(\"img\") ) ? $obj : $obj.find(\"img\");\n\n                /*\n                 *\n                 * Set the width of the image and parent element\n                 * if the resized element is not an image, we apply it to the child image also\n                 *\n                 * We need to check if it's an image as the css borders are only measured on\n                 * images. If the parent is a div, we need make the contained image smaller\n                 * to accommodate the css image borders.\n                 *\n                 */\n                $img.width(fw);\n                if( !$obj.is(\"img\") ){\n                    $obj.width(fw + obj[i][3]);\n                }\n\n\n                /*\n                 *\n                 * Set the height of the image\n                 * if the resized element is not an image, we apply it to the child image also\n                 *\n                 */\n                $img.height(fh);\n                if( !$obj.is(\"img\") ){\n                    $obj.height(fh + obj[i][4]);\n                }\n\n\n                /*\n                 *\n                 * Apply the css extras like padding\n                 *\n                 */\n                applyModifications($obj, isNotLast, settings);\n\n\n                /*\n                 *\n                 * Assign the effect to show the image\n                 * Default effect is using jquery and not CSS3 to support more browsers\n                 * Wait until the image is loaded to do this\n                 *\n                 */\n\n                $img\n                    .one('load', function (target) {\n                    return function(){\n                        if( settings.effect == 'default'){\n                            target.animate({opacity: '1'},{duration: settings.fadeSpeed});\n                        } else {\n                            if(settings.direction == 'vertical'){\n                                var sequence = (rownum <= 10  ? rownum : 10);\n                            } else {\n                                var sequence = (i <= 9  ? i+1 : 10);\n                            }\n                            /* Remove old classes with the \"effect-\" name */\n                            target.removeClass(function (index, css) {\n                                return (css.match(/\\beffect-\\S+/g) || []).join(' ');\n                            });\n                            target.addClass(settings.effect);\n                            target.addClass(\"effect-duration-\" + sequence);\n                        }\n                    }\n                    }($obj))\n                    /*\n                     * fix for cached or loaded images\n                     * For example if images are loaded in a \"window.load\" call we need to trigger\n                     * the load call again\n                     */\n                    .each(function() {\n                            if(this.complete) $(this).trigger('load');\n                    });\n\n        }\n\n\n\n\n\n        }\n\n        /*\n         *\n         * This private function applies the required css to space the image gallery\n         * It applies it to the parent element so if an image is wrapped in a <div> then\n         * the css is applied to the <div>\n         *\n         */\n        function applyModifications($obj, isNotLast, settings) {\n            var css = {\n                    // Applying padding to element for the grid gap effect\n                    'margin-bottom'     : settings.padding + \"px\",\n                    'margin-right'      : (isNotLast) ? settings.padding + \"px\" : \"0px\",\n                    // Set it to an inline-block by default so that it doesn't break the row\n                    'display'           : settings.display,\n                    // Set vertical alignment otherwise you get 4px extra padding\n                    'vertical-align'    : \"bottom\",\n                    // Hide the overflow to hide the caption\n                    'overflow'          : \"hidden\"\n                };\n\n            return $obj.css(css);\n        }\n\n\n        /*\n         *\n         * This private function calculates any extras like padding, border associated\n         * with the image that will impact on the width calculations\n         *\n         */\n        function getImgProperty( img )\n        {\n            $img = $(img);\n            var params =  new Array();\n            params[\"w\"] = (parseFloat($img.css(\"border-left-width\")) + parseFloat($img.css(\"border-right-width\")));\n            params[\"h\"] = (parseFloat($img.css(\"border-top-width\")) + parseFloat($img.css(\"border-bottom-width\")));\n            return params;\n        }\n\n    };\n\n    $.fn.collagePlus.defaults = {\n        // the ideal height you want your images to be\n        'targetHeight'          : 400,\n        // how quickly you want images to fade in once ready can be in ms, \"slow\" or \"fast\"\n        'fadeSpeed'             : \"fast\",\n        // how the resized block should be displayed. inline-block by default so that it doesn't break the row\n        'display'               : \"inline-block\",\n        // which effect you want to use for revealing the images (note CSS3 browsers only),\n        'effect'                : 'default',\n        // effect delays can either be applied per row to give the impression of descending appearance\n        // or horizontally, so more like a flock of birds changing direction\n        'direction'             : 'vertical',\n        // Sometimes there is just one image on the last row and it gets blown up to a huge size to fit the\n        // parent div width. To stop this behaviour, set this to true\n        'allowPartialLastRow'   : false\n    };\n\n})( jQuery );","/**\n * zoom.js - It's the best way to zoom an image\n * @version v0.0.2\n * @link https://github.com/fat/zoom.js\n * @license MIT\n */\n\n+function ($) { \"use strict\";\n\n  /**\n   * The zoom service\n   */\n  function ZoomService () {\n    this._activeZoom            =\n    this._initialScrollPosition =\n    this._initialTouchPosition  =\n    this._touchMoveListener     = null\n\n    this._$document = $(document)\n    this._$window   = $(window)\n    this._$body     = $(document.body)\n\n    this._boundClick = $.proxy(this._clickHandler, this)\n  }\n\n  ZoomService.prototype.listen = function () {\n    this._$body.on('click', '[data-action=\"zoom\"]', $.proxy(this._zoom, this))\n  }\n\n  ZoomService.prototype._zoom = function (e) {\n    var target = e.target\n\n    if (!target || target.tagName != 'IMG') return\n\n    if (this._$body.hasClass('zoom-overlay-open')) return\n\n    if (e.metaKey || e.ctrlKey) {\n      return window.open((e.target.getAttribute('data-original') || e.target.src), '_blank')\n    }\n\n    if (target.width >= ($(window).width() - Zoom.OFFSET)) return\n\n    this._activeZoomClose(true)\n\n    this._activeZoom = new Zoom(target)\n    this._activeZoom.zoomImage()\n\n    // todo(fat): probably worth throttling this\n    this._$window.on('scroll.zoom', $.proxy(this._scrollHandler, this))\n\n    this._$document.on('keyup.zoom', $.proxy(this._keyHandler, this))\n    this._$document.on('touchstart.zoom', $.proxy(this._touchStart, this))\n\n    // we use a capturing phase here to prevent unintended js events\n    // sadly no useCapture in jquery api (http://bugs.jquery.com/ticket/14953)\n    if (document.addEventListener) {\n      document.addEventListener('click', this._boundClick, true)\n    } else {\n      document.attachEvent('onclick', this._boundClick, true)\n    }\n\n    if ('bubbles' in e) {\n      if (e.bubbles) e.stopPropagation()\n    } else {\n      // Internet Explorer before version 9\n      e.cancelBubble = true\n    }\n  }\n\n  ZoomService.prototype._activeZoomClose = function (forceDispose) {\n    if (!this._activeZoom) return\n\n    if (forceDispose) {\n      this._activeZoom.dispose()\n    } else {\n      this._activeZoom.close()\n    }\n\n    this._$window.off('.zoom')\n    this._$document.off('.zoom')\n\n    document.removeEventListener('click', this._boundClick, true)\n\n    this._activeZoom = null\n  }\n\n  ZoomService.prototype._scrollHandler = function (e) {\n    if (this._initialScrollPosition === null) this._initialScrollPosition = $(window).scrollTop()\n    var deltaY = this._initialScrollPosition - $(window).scrollTop()\n    if (Math.abs(deltaY) >= 40) this._activeZoomClose()\n  }\n\n  ZoomService.prototype._keyHandler = function (e) {\n    if (e.keyCode == 27) this._activeZoomClose()\n  }\n\n  ZoomService.prototype._clickHandler = function (e) {\n    if (e.preventDefault) e.preventDefault()\n    else event.returnValue = false\n\n    if ('bubbles' in e) {\n      if (e.bubbles) e.stopPropagation()\n    } else {\n      // Internet Explorer before version 9\n      e.cancelBubble = true\n    }\n\n    this._activeZoomClose()\n  }\n\n  ZoomService.prototype._touchStart = function (e) {\n    this._initialTouchPosition = e.touches[0].pageY\n    $(e.target).on('touchmove.zoom', $.proxy(this._touchMove, this))\n  }\n\n  ZoomService.prototype._touchMove = function (e) {\n    if (Math.abs(e.touches[0].pageY - this._initialTouchPosition) > 10) {\n      this._activeZoomClose()\n      $(e.target).off('touchmove.zoom')\n    }\n  }\n\n\n  /**\n   * The zoom object\n   */\n  function Zoom (img) {\n    this._fullHeight      =\n    this._fullWidth       =\n    this._overlay         =\n    this._targetImageWrap = null\n\n    this._targetImage = img\n\n    this._$body = $(document.body)\n  }\n\n  Zoom.OFFSET = 80\n  Zoom._MAX_WIDTH = 2560\n  Zoom._MAX_HEIGHT = 4096\n\n  Zoom.prototype.zoomImage = function () {\n    var img = document.createElement('img')\n    img.onload = $.proxy(function () {\n      this._fullHeight = Number(img.height)\n      this._fullWidth = Number(img.width)\n      this._zoomOriginal()\n    }, this)\n    img.src = this._targetImage.src\n  }\n\n  Zoom.prototype._zoomOriginal = function () {\n    this._targetImageWrap           = document.createElement('div')\n    this._targetImageWrap.className = 'zoom-img-wrap'\n\n    this._targetImage.parentNode.insertBefore(this._targetImageWrap, this._targetImage)\n    this._targetImageWrap.appendChild(this._targetImage)\n\n    $(this._targetImage)\n      .addClass('zoom-img')\n      .attr('data-action', 'zoom-out')\n\n    this._overlay           = document.createElement('div')\n    this._overlay.className = 'zoom-overlay'\n\n    document.body.appendChild(this._overlay)\n\n    this._calculateZoom()\n    this._triggerAnimation()\n  }\n\n  Zoom.prototype._calculateZoom = function () {\n    this._targetImage.offsetWidth // repaint before animating\n\n    var originalFullImageWidth  = this._fullWidth\n    var originalFullImageHeight = this._fullHeight\n\n    var scrollTop = $(window).scrollTop()\n\n    var maxScaleFactor = originalFullImageWidth / this._targetImage.width\n\n    var viewportHeight = ($(window).height() - Zoom.OFFSET)\n    var viewportWidth  = ($(window).width() - Zoom.OFFSET)\n\n    var imageAspectRatio    = originalFullImageWidth / originalFullImageHeight\n    var viewportAspectRatio = viewportWidth / viewportHeight\n\n    if (originalFullImageWidth < viewportWidth && originalFullImageHeight < viewportHeight) {\n      this._imgScaleFactor = maxScaleFactor\n\n    } else if (imageAspectRatio < viewportAspectRatio) {\n      this._imgScaleFactor = (viewportHeight / originalFullImageHeight) * maxScaleFactor\n\n    } else {\n      this._imgScaleFactor = (viewportWidth / originalFullImageWidth) * maxScaleFactor\n    }\n  }\n\n  Zoom.prototype._triggerAnimation = function () {\n    this._targetImage.offsetWidth // repaint before animating\n\n    var imageOffset = $(this._targetImage).offset()\n    var scrollTop   = $(window).scrollTop()\n\n    var viewportY = scrollTop + ($(window).height() / 2)\n    var viewportX = ($(window).width() / 2)\n\n    var imageCenterY = imageOffset.top + (this._targetImage.height / 2)\n    var imageCenterX = imageOffset.left + (this._targetImage.width / 2)\n\n    this._translateY = Math.round(viewportY - imageCenterY)\n    this._translateX = Math.round(viewportX - imageCenterX)\n\n    var targetTransform = 'scale(' + this._imgScaleFactor + ')'\n    var imageWrapTransform = 'translate(' + this._translateX + 'px, ' + this._translateY + 'px)'\n\n    if ($.support.transition) {\n      imageWrapTransform += ' translateZ(0)'\n    }\n\n    $(this._targetImage)\n      .css({\n        '-webkit-transform': targetTransform,\n            '-ms-transform': targetTransform,\n                'transform': targetTransform\n      })\n\n    $(this._targetImageWrap)\n      .css({\n        '-webkit-transform': imageWrapTransform,\n            '-ms-transform': imageWrapTransform,\n                'transform': imageWrapTransform\n      })\n\n    this._$body.addClass('zoom-overlay-open')\n  }\n\n  Zoom.prototype.close = function () {\n    this._$body\n      .removeClass('zoom-overlay-open')\n      .addClass('zoom-overlay-transitioning')\n\n    // we use setStyle here so that the correct vender prefix for transform is used\n    $(this._targetImage)\n      .css({\n        '-webkit-transform': '',\n            '-ms-transform': '',\n                'transform': ''\n      })\n\n    $(this._targetImageWrap)\n      .css({\n        '-webkit-transform': '',\n            '-ms-transform': '',\n                'transform': ''\n      })\n\n    if (!$.support.transition) {\n      return this.dispose()\n    }\n\n    $(this._targetImage)\n      .one($.support.transition.end, $.proxy(this.dispose, this))\n      .emulateTransitionEnd(300)\n  }\n\n  Zoom.prototype.dispose = function () {\n    if (this._targetImageWrap && this._targetImageWrap.parentNode) {\n      $(this._targetImage)\n        .removeClass('zoom-img')\n        .attr('data-action', 'zoom')\n\n      this._targetImageWrap.parentNode.replaceChild(this._targetImage, this._targetImageWrap)\n      this._overlay.parentNode.removeChild(this._overlay)\n\n      this._$body.removeClass('zoom-overlay-transitioning')\n    }\n  }\n\n  // wait for dom ready (incase script included before body)\n  $(function () {\n    new ZoomService().listen()\n  })\n\n}(jQuery)","$(function() {\n\t\n\t// Automatically add Zoom interaction\n\t$('article.content img').attr('data-action', 'zoom');\n\n\t// Make captions from Alt tags\n\t$('img.captioned').each(function() {\n\t\tvar caption = $(this).attr('alt') || false;\n\t\tif (caption) {\n\t\t\t$(this).after('<p class=\"caption\">' + caption + '</p>');\n\t\t}\n\t});\n\n\t// Auto focus on the giant search box\n\tvar search = $('input.giant.search');\n\tsearch.focus().val(search.val());\n\n\t// Fire up that gallery\n\t$(window).load(function () {\n\t\tcollage();\n\t});\n\n\t// Anima\n\n\t$('#nav-main .search').focus(function() {\n\t\t$(this).addClass('grow');\n\t}).blur(function() {\n\t\t$(this).removeClass('grow');\n\t});\n});\n\nfunction collage() {\n\t$('.gallery-images').collagePlus({\n\t\t'fadeSpeed' : 300\n    });\n}\n\n// Reinitialize the gallery on browser resize.\nvar resizeTimer = null;\n$(window).bind('resize', function() {\n    $('.gallery-images img').css(\"opacity\", 0);\n    \n    if (resizeTimer) clearTimeout(resizeTimer);\n    \n    resizeTimer = setTimeout(collage, 200);\n});"]}